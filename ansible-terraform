How to install terraform and terraform-libvirt-provider on remote bare metal Debian server using Ansible.
Soo… kids, in today's class we will install and config the next big automation buzz word out there "Terraform" on our bare-metal server and we will also build a plugin called "terraform-libvirt-provider" using Ansible( this plugin's required if you wish to manage a libvirt based VMs on the Host server), to see how to install KVM and libvirt on a remote server (using Ansible)have a look at my previous post<put link here>.

this is rather a very simple post, here we will create 2 roles to do the following:
- install terraform on a remote server
- clone and build the terraform-libvirt-provider binary (using "go") and init terrafom with this plugin for this ansible user.
- Role terrafom
here we do the folowing in the following order:
/roles/terraform/tasks/debian.yml
https://gist.github.com/github-somerandomguy-xyz/c3c4c6d0c4cb059b522ef76ab7fac9e3
All it take to install terraform is to download their terrafom binary and place it in the right folder.
Basically all you need is uzip to unzip the download.
so first we "ensure" that all the prerequisites are available(.i.e. uzip package)
next you just download terrafom and put it in it's place.
Random Rant, follows, feel free to skip this section.
the best way to not get trapped in golang's fun trip with setting PATH varibles rollercoster ride is to never touch that mess.
to never be able to touch it, i made sure I used the right user to run the go command.
let me explain: here the goal is to create the binary for the lib-virt provider.
in there documentation they say it would be created in the gopath's "bin" folder.
go was complaining it could not find the go path something like that.
so offcourse I set the PATH vars all over the place, and used the .profile as the source esscentially also simulated the logout login function, Go keeps nagging about some carp ether it goroot gohome etc,. i cannot get into explaining the BS, that you have to go through while useing golang... i mean am sure golang works perfectly well for simps, who would install it manually and do the following stuff manually like a chimp, but since i took this new gig to automate everything(almost like a suicide mission for my own carrier), this PATH setting env vars nonsence with golang dosn't fly.
this is especially true if you are a nonroot user and want to use go commands directly (as in `go get blah_blah`).
so.. anyhow the main lession learnt is to use the full path of the go binary for executing go commands, and try not to touch the PATH env vars at all.
/roles/terraform-libvirt-provider/tasks/debian.yml
Note: for those who (righly) skipped my rant:
1. It's kinda important to switch from root user to the non-root user while using golang to build this plugin (switch to whichever your user would be running your terrafom code in the future(in my case it will be the same ansible user on the server)).
2. to avoid confusing the OS to find the goland binary, it's also important to give the full path to the golang binary when executing `go` commands.
Random Insights and rants, feel free to skip this section:
Ideally I would love to have a ansible role to do the terraform_apply, this role would just copy the terraform .ts files and cloud-init config filles to the remote server and execute `terrafomr apply` on the btch.
but I learnt the hard way, that that this strategy would seldom be idemopotent:
here's my use-case: during my trials to setup this infra, i previously tested my terrafom configs and executed them, later I destroyed everything (using terraform destroy) but some residue was still left behind (like the libvirt network, VM images etc,.).
on the other this, this scenario, made me realize, if you already have an existing infra (some cloud setup with VMs and bridges/networks etc,.) we need to "import" these resources to terraform state anyways.
so am left with two choices, I can either nuke the entire server and start managing the terrafom orcestrated infra on a "virgin" server.
or I could run terrafom import for all the existing resources.
I belive in most cases, in real world, the latter would be the case (I dont think any self respecting admin with a pulse, would leave the server in it'S virgin state for that long).
aah, so…the next task for me looks like this:
1. I could write a blog post on how to set install VMs and network configs etc,. on a fresh server, without ansible (basically you login clone the code do changes and execcute terrafom plan and apply cmds). ("must-have" task).
2. write a post on how to import exising infra to terrafom state and continue maintining from there to orcestrate the infra. ("should-have" task)
3. do above point 2, using ansible, perhaps ansible can use the "ansible facts" data as input to decide which resources to import to the terraform state. ("nice-to-have" task).
This would ideally be the place where everything comes together finally.
the big climax, ( that never happened #spolerAlert #toolate)
even thought this would work perfectly well if your baremetal server is a virgin server,
but unfortunately that's seldom the case in the real world, no self respcting admins with a pulse, would let that be the case(… I think).
but in my case the issue was there was already an preexisting infra on the server (mainly networkconfigs and virsh VMs managed by KVM hypervisers), now the terraformform docs do give a nifty soultions for this, using "imports" or something <do proper reasearch on why we cannot codify all the imports on existing infra> am not really sure how it works, based on the 2nd hand info from stackoverflow and googing around, i see that i should execute the "import"on terraform cli, i find this sooultion ugly, i woulld rather mentione it in the code, to import all the exising infra,
one idea is to use the ansible facts as the input for the terraform imports and make terraform initialize and maintain a terraform state from there.<should do reasearch on, weather it's possiable, if nt why it's not possablle">
/roles/terraform_apply/tasks/debian.yml